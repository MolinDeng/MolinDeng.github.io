<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串匹配算法--KMP&Sunday]]></title>
    <url>%2Fpost%2F85e77adc.html</url>
    <content type="text"><![CDATA[Here’s a string “BBC ABCDAB ABCDABCDABDE”，I wanna know，if it contains another string “ABCDABD”.&lt;/br&gt;We call “ABCDABD” search string or key, the other is source string Knuth-Morris-Pratt算法123BBC ABCDAB ABCDABCDABDE|ABCDABD First, we make comparation one by one. B and A not match, we slide key one byte backward. 123BBC ABCDAB ABCDABCDABDE | ABCDABD Still, move backward. 123BBC ABCDAB ABCDABCDABDE | ABCDABD Till we find the same character. 123BBC ABCDAB ABCDABCDABDE | ABCDABD Now move to next char. until we find the difference. Stop and thinking. If we move key one char. backward and compare it from head, efficiency sucks. We can fully use the matching sub-string “ABCDAB” to get some information which used to skip some comparations. 最直观地，我们可以看见在已经匹配字符串”ABCDAB”中，首部子串”AB”和尾部子串”AB”是匹配的，那么直接将search string移动到对应位置使得search string首部的”AB”和source string尾部的”AB”对应。 123BBC ABCDAB ABCDABCDABDE | ABCDABD 前缀与后缀以及《部分匹配表》（Partial Match Table）&lt;/br&gt;”前缀”指除了最后一个字符以外，一个字符串的全部头部子串构成的集合，必须从头开始；&lt;/br&gt;”后缀”指除了第一个字符以外，一个字符串的全部尾部组合构成的集合，必须从尾部开始。 Partial Match Table就是前缀和后缀的最长共有子串的长度 string prefix postfix partial match length “A” $\emptyset$ $\emptyset$ 0 “AB” [A] [B] 0 “ABC” [A, AB] [BC, C] 0 “ABCD” [A, AB, ABC] [BCD, CD, D] 0 “ABCDA” [A, AB, ABC, ABCD] [BCDA, CDA, DA, A] 1 “ABCDAB” [A, AB, ABC, ABCD, ABCDA] [BCDAB, CDAB, DAB, AB, B] 2 “ABCDABD” [A, AB, ABC, ABCD, ABCDA, ABCDAB] [BCDABD, CDABD, DABD, ABD, BD, D] 0 现在我们得到了《部分匹配表》 search key A B C D A B D PML 0 0 0 0 1 2 0 当D和`不匹配时，已匹配的子串&quot;ABCDAB&quot;的部分匹配值是2，那么search key向后移动4`位 1移动位数 = 已匹配的字符数 - 对应的部分匹配值 // 4 = 6 - 2 123BBC ABCDAB ABCDABCDABDE | ABCDABD 此时C与`不匹配，search key向后移动2-0=2`位 123BBC ABCDAB ABCDABCDABDE | ABCDABD 因为`与A`不匹配，继续后移一位。 123BBC ABCDAB ABCDABCDABDE | ABCDABD 以此类推~ 计算PMT123456789void makenxt(string&amp; P, vector&lt;int&gt;&amp; nxt) &#123; int len = P.length(); for(int i = 1, l = 0; i &lt; len; i++) &#123; while(l &gt; 0 &amp;&amp; P[l] != P[i]) l = nxt[l-1]; if(P[l] == P[i]) l++; nxt[i] = l; &#125;&#125; 以下引用c_cloud的解释 已知前一步计算时最大相同的前后缀长度为k（k&gt;0），即P[0]···P[k-1]； 此时比较第k项P[k]与P[q],如图1所示 如果P[K]等于P[q]，那么很简单跳出while循环; 关键！关键有木有！关键如果不等呢？那么我们应该利用已经得到的next[0]···next[k-1]来求P[0]···P[k-1]这个子串中最大相同前后缀，可能有同学要问了——为什么要求P[0]···P[k-1]的最大相同前后缀呢？？？是啊！为什么呢？ 原因在于P[k]已经和P[q]失配了，而且P[q-k] ··· P[q-1]又与P[0] ···P[k-1]相同，看来P[0]···P[k-1]这么长的子串是用不了了，那么我要找个同样也是P[0]打头、P[k-1]结尾的子串即P[0]···Pj-1，看看它的下一项P[j]是否能和P[q]匹配。如图所示 Full code 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void makenxt(string&amp; P, vector&lt;int&gt;&amp; nxt) &#123; int len = P.length(); for(int i = 1, l = 0; i &lt; len; i++) &#123; while(l &gt; 0 &amp;&amp; P[l] != P[i]) l = nxt[l-1]; if(P[l] == P[i]) l++; nxt[i] = l; &#125;&#125;void kmp(string&amp; S, string&amp; P) &#123; vector&lt;int&gt; nxt(P.length(), 0); makenxt(P, nxt); for(auto i : nxt) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl; for(int i = 0, j = 0; i &lt; S.length(); i++) &#123; while(j &gt; 0 &amp;&amp; P[j] != S[i]) j = nxt[j-1]; if(P[j] == S[i]) j++; if(j == P.length()) &#123; cout &lt;&lt; "Pattern starts with idx: " &lt;&lt; i-P.length()+1 &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; "Not Found" &lt;&lt; endl;&#125;int main() &#123; string S = "BBC ABCDAB ABCDABCDABDE"; string P = "ABCDABD"; kmp(S, P); return 0;&#125; Sunday 算法Here’s a string “substring searching”，I wanna know，if it contains another string “search”. 123substring searching |search 第2个字符不匹配，这个时候我们关注source string中末位对齐位置的下一个字符，即字符i，i不在search string中，那么以下几种位置都是不可能匹配的，因为i的存在 12345678910111213substring searching ||||||||||| search||||| |||||||||| search|||| ||||||||| search||| |||||||| search|| ||||||| search| |||||| search 因此，将search string向后移动m+1位（m是search key长度），如下所示 123substring searching |||||| search 此时，第一个字符不匹配，再看末位对齐位置的下一个字符，即字符r，r在search string中，那么向后移动search string6 - 3 = 3位，使得source string中r与search string中最后一个r对齐 123substring searching |||||| search Shift table《偏移表》是针对source string建立的，而《部分匹配表》是针对search string建立的 shift[c]= \begin{cases} m-max\{i]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>kmp</tag>
        <tag>sunday</tag>
        <tag>string</tag>
        <tag>match</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-OJ]]></title>
    <url>%2Fpost%2F4c3ebdcd.html</url>
    <content type="text"><![CDATA[Everyday programing ! See solutions on My LeetCode 1. Two Sum BF with binary search 哈希表T = O(N) S = O(N) 建立value-index映射 依次遍历，如果另一半在map中，返回当前下标i和map[另一半]；反之将当前&lt;value, index&gt;插入map 2. Add Two Numbers 两数相加，两数用链表形式表示 3. Longest Substring Without Repeating Characters 滑动窗口[i, j] 每次向右滑动j，当遇到之前重复出现的字符c时，此时[i, j-1]区间没有重复的，i定位到max(i, 上一个c的位置+1)，此时[i, j]之间消除了重复字符c O(N) 4. Median of Two Sorted Arrays O(m+n) 类似于归并排序，对奇偶有不同的要求 5. Longest Palindromic Substring 给出一个字符串s，求s的最长回文字串的长度 dp[i][j]表示s[i]到s[j]所表示的字串是否是回文字串。只有0和1 递推方程： 当s[i] == s[j] : dp[i][j] = dp[i+1][j-1] 当s[i] != s[j] : dp[i][j] =0 边界i == j || j = i+1：dp[i][j] = 1, dp[i][i+1] = (s[i] == s[i+1]) ? 1 : 0 123for(int i = len - 1; i &gt;= 0; --i) &#123; for(int j = i; j &lt; len; ++j) &#123; if(s[i] == s[j] &amp;&amp; (j - i &lt; 3 || dp[i+1][j-1])) &#123; 上述判断可以解决边界的判断 6. ZigZag Conversion 储存为一个二维的vector，以不同的顺序遍历得到结果T = O(N) S = O(N) 通过计算位置依次遍历S = O(1) 7. Reverse Integer 通过计算反转 123456while(x) &#123; ret *= 10; ret += x % 10; if(ret &gt; INT_MAX || ret &lt; INT_MIN) return 0; x /= 10;&#125; 8. String to Integer (atoi) find_if、find_if_not搭配匿名函数很方便的 9. Palindrome Number 判断一半即可 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return false; int sum = 0; while(x &gt; sum) &#123; sum = sum * 10 + x % 10; x /= 10; &#125; return (x == sum) || (x == sum/10); &#125;&#125;; 10. Regular Expression Matching using C++11 \ 12regex r(p);return regex_match(s, r); dp 11. Container With Most Water Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don’t support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left 12. Integer to Roman 最多四位数，以数组的形式定义每个位的一个数字关于符号的映射 1234string M[] = &#123;"", "M", "MM", "MMM"&#125;;string C[] = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;;string X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;;string I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; 13. Roman to Integer 先建立字母-数字映射 从后往前读 当前位数字&gt;=已经读到的数字中的最大值，结果加上 反之，结果减去 14. Longest Common Prefix(LCP) 顺序比较：T = O(S) S = O(1) S is the sum of all chars Divide and conquer Binary search Prefix Trie(TODO) 以字符串排序，LSP(S1,S2,...,Sn)=LSP(S1, Sn)]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>OJ</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-Advanced-Level]]></title>
    <url>%2Fpost%2F62ae0339.html</url>
    <content type="text"><![CDATA[Everyday programing ! See Solutions on My PAT 2018.9.8 PAT A Level 1001(字符串处理) string operation using insert insert function cannot accept reverse_iterator reverse the whole string, then do it as normal convert reverse_it to it (not try, maybe not work) 1str.insert(r_iter.base(), 1, ','); for each iteration, we should update iterator 1iter = str.insert(iter, ','); http://www.cplusplus.com/reference/string/string/insert/ 1002(两路merge) two-way merge 1003(Dijkstra算法 点带权) my code using priority queue 22/25 using Dij Algorithm to find shortest path using priority queue to find vertex to visit before push into queue, we need to find if the id in queue self-defined cmp function for determining priority 12345struct mycmp &#123; bool operator()(int i, int j) &#123; return s_dist[i] &gt; s_dist[j]; &#125;&#125;; using vector]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
        <tag>ZJU-PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to build this blog using Hexo and GitHub Pages]]></title>
    <url>%2Fpost%2F3ace9508.html</url>
    <content type="text"><![CDATA[Tools Markdown：文章编写，内置层级、列表、超链接、图片插入、代码、数学公式等语法支持 Hexo：博客构建，快速搭建生成预览、发布 GitHub Pages：使用GitHub Pages托管，免费 Environment Node.js 1$ npm config set registry https://registry.npm.taobao.org # change source Hexo 12345$ npm install -g hexo-cli$ cd Blogs/ # your own file folder$ hexo init # initialize$ hexo install # or npm install# then u can generate an example 常用命令见Cheating Sheet Git Using NexT theme 下载主题 12$ cd &lt;your-hexo-site&gt;$ git clone https://github.com/theme-next/hexo-theme-next themes/next 启用主题 编辑_config.yml 1theme: next # 冒号后面有一个空格 设置语言 编辑_config.yml 123theme: - zh-Hans # -后面有一个空格- en Deploy GitHub Pages 在自己的GitHub账号下创建username.github.io的repo 设置SSH，详情参考廖雪峰的GIt教程 安装git-deploy插件 1$ npm install hexo-deployer-git -–save 关联仓库：编辑_config.yml 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 部署 1$ hexo g -d Binding your Domain name 购买域名 等待实名认证 解析域名 1$ ping &lt;usrename&gt;.github.io # get ip addr 配置如下2条 记录类型A主机记录@记录值ip-addr 记录类型CANME主机记录www记录值username.github.io 在hexo-site/source/中新建CNAME（无后缀名） 1&lt;your-domain-name&gt; # 加不加www看个人喜好 等待DNS生效 Hexo Configuration 头像：在\hexo-site\themes\next\_config.yml中设置avatar: &lt;avatar-url&gt; 可以放在\hexo-site\themes\next\source\images中直接引用url: /images/avatar.png 添加tag页面 1$ hexo new page tags 编辑source/tags/index.md 1234---type: "tags"comments: false--- 编辑themes/next/_config.yml 12menu: tags: /tags 新建categories页面，同上 新建about页面，同上，编辑这个md文件就可以自我介绍了 首页文章显示摘要&lt;!--more--&gt; 显示文章更新时间、创建时间以及其他总结信息 编辑themes/next/_config.yml 12345678# Post meta display settingspost_meta: item_text: true created_at: true updated_at: enabled: true another_day: true categories: true 显示文章统计信息 编辑themes/next/_config.yml注意注释中的依赖 12345# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true 代码块复制按钮、高亮 编辑themes/next/_config.yml 12345678# Add copy button on codeblockcopy_button: enable: true...# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 打赏信息 编辑themes/next/_config.yml 1234# Rewardreward_comment: You can buy me some snacks🍕🌭 ^_^wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 添加 Creative Commons 署名协议 编辑themes/next/_config.yml 12post_copyright: enable: true 字体设置在themes/next/_config.yml中的font字段 global全局字体 headings标头字体，就是h1,h2,h3…的字体 posts文章字体 logo左上角logo的字体Morning’s blog codes代码快字体 评论区 注册livere账号 生成livere_uid：在Code Managing中复制如下代码到配置文件中themes/next/_config.yml 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: **********************== 本地关键词搜索 安装hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 编辑_config.yml 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml 12local_search: enable: true Fancybox For install 3.x: https://github.com/theme-next/theme-next-fancybox3 编辑themes/next/_config.yml 1fancybox: true 右侧社交栏 编辑themes/next/_config.yml查找social link字段 腾讯公益404 新建&lt;hexo-site&gt;/source/404.html 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 站点生成时间 编辑themes/next/_config.yml 1since: 2018 添加sitemap插件 安装 hexo-generator-sitemap 插件 1$ npm install hexo-generator-sitemap --save 编辑 _config.yml 12sitemap: path: sitemap.xml 添加蜘蛛协议 创建&lt;hexo-site&gt;/source/robots.txt 12345678910111213141516User-agent: *Disallow: /CNAMEDisallow: /READMEAllow: /Allow: /about/Allow: /archives/Allow: /categories/Allow: /tags/Allow: /css/Allow: /images/Allow: /js/Allow: /lib/Sitemap: &lt;your-domain-name&gt;/sitemap.xml 设置RSS 安装hexo-generator-feed 插件 1$ npm install hexo-generator-feed --save 编辑 _config.yml 123456feed: type: atom path: atom.xml limit: 20 # Maximum number of posts in the feed (Use 0 or false to show all posts) hub: content: BeautificationHexo+Next主题优化&lt;/br&gt;hexo + next主题高级配置&lt;/br&gt; ReferencesHexo - 修改永久链接的默认格式（重要）&lt;/br&gt;如何在一天之内搭建以你自己名字为域名又具备 cool 属性的个人博客&lt;/br&gt;hexo博客优化之实现来必力评论功能&lt;/br&gt;如何使用 Hexo 和 GitHub Pages 搭建这个博客&lt;/br&gt;使用 Travis 自动部署博客到 Github Pages&lt;/br&gt;hexo next主题 解决首页文章间距过宽的问题&lt;/br&gt;使用LaTex添加公式到Hexo博客里]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cheating Sheet]]></title>
    <url>%2Fpost%2Fd41a18cb.html</url>
    <content type="text"><![CDATA[Markdown 1个空格：&amp;nbsp; 字体、字号、颜色：&lt;font face=&quot;Charmonman&quot; size= 2 color=blue&gt;something&lt;/font&gt;test 段内换行：&lt;/br&gt; 显示摘要：&lt;!--more--&gt; Hexo 初始化目录：hexo init [folder] 新建文章：hexo new [layout] &lt;title&gt;或hexo n [layout] &lt;title&gt; 新建草稿：hexo new draft &lt;title&gt; 将草稿发布为正式文章：hexo publish &lt;title&gt; 生成静态文件：hexo generate或hexo g 监听文件变化：hexo g --watch 或 hexo g -w 部署：hexo deploy或hexo d 先生成后部署：hexo d -g 启动本地服务器（服务器会监听文件变化并自动更新）：hexo server或hexo s 启动调试：hexo s --debug 预览草稿：hexo s --draft 清除缓存：hexo clean LaTeX常用数学符号的 LaTeX 表示方法]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
