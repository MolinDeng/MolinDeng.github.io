<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NexT主题自定义字体(CSS样式)]]></title>
    <url>%2Fpost%2Fa65b35ad.html</url>
    <content type="text"><![CDATA[My versionHexo v3.7.1Theme – NexT.Mist v6.4.2 如何载入字体、设置各个模块格式，可以通过观察&lt;hexo-site&gt;\public\css\main.css中的定义来模仿，然后在&lt;hexo-site&gt;\themes\next\source\css\_custom\custom.styl中覆写相关定义。 Attention1.路径问题：主题相关设置都是相对themes/next/source/；发布之后的相关设置是相对public/2.修改主题相关文件需要执行hexo c3.可以在public/css/main.css中末尾检查新的样式，custom.styl中的代码都会添加到main.css的末尾 自定义font-face 下载字体Google Fonts，将字体文件放在themes/next/source/fonts/中，hexo发布之后会把fonts目录复制到public/中，所以引入的相对目录是/fonts/Charmonman-Regular.ttf 编辑&lt;hexo-site&gt;\themes\next\source\css\_custom\custom.styl 1234567891011@font-face &#123; font-family: Charmonman; src: url('/fonts/Charmonman-Regular.ttf'); font-weight: normal;&#125;@font-face &#123; font-family: Charmonman; src: url('/fonts/Charmonman-Bold.ttf'); font-weight: 700;&#125; 使用字体 通过编辑&lt;hexo-site&gt;\themes\next\source\css\_custom\custom.styl logo对应的element是site-tile 123456.site-title &#123; line-height: 36px !important; font-size: 20px !important; font-weight: normal !important; font-family: 'Charmonman' !important;&#125; 通过编辑themes/next/_config.yml 这种方法需要从font host载入字体族，有时会造成载入速度变慢，而我自己搭建过程中发现设置字体无法在其他PC中显示，只能在本地Chrome中显示（Edge也不行），遂载入静态字体 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). # //fonts.lug.ustc.edu.cn # //fonts.css.network # //fonts.loli.net # //fonts.proxy.ustclug.org # //fonts.useso.com # https://fonts.gmirror.org/ host: https://fonts.googleapis.com # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used for all elements in &lt;body&gt;. global: external: true family: Lato size: # Font settings for Headlines (H1, H2, H3, H4, H5, H6). # Fallback to `global` font settings. headings: external: true family: IBM Plex Sans size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: Lato # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: Charmonman size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Consolas size: 13 References Next主题自定义CSS样式（字体）Hexo+Next主题优化]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>font</tag>
        <tag>CSS</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配算法--KMP&Sunday]]></title>
    <url>%2Fpost%2F85e77adc.html</url>
    <content type="text"><![CDATA[Here’s a string “BBC ABCDAB ABCDABCDABDE”，I wanna know，if it contains another string “ABCDABD”.We call “ABCDABD” search string or key, the other is source string Knuth-Morris-Pratt算法123BBC ABCDAB ABCDABCDABDE|ABCDABD First, we make comparation one by one. B and A not match, we slide key one byte backward. 123BBC ABCDAB ABCDABCDABDE | ABCDABD Still, move backward. 123BBC ABCDAB ABCDABCDABDE | ABCDABD Till we find the same character. 123BBC ABCDAB ABCDABCDABDE | ABCDABD Now move to next char. until we find the difference. Stop and thinking. If we move key one char. backward and compare it from head, efficiency sucks. We can fully use the matching sub-string “ABCDAB” to get some information which used to skip some comparations. 最直观地，我们可以看见在已经匹配字符串”ABCDAB”中，首部子串”AB”和尾部子串”AB”是匹配的，那么直接将search string移动到对应位置使得search string首部的”AB”和source string尾部的”AB”对应。 123BBC ABCDAB ABCDABCDABDE | ABCDABD 前缀与后缀以及《部分匹配表》（Partial Match Table）“前缀”指除了最后一个字符以外，一个字符串的全部头部子串构成的集合，必须从头开始；“后缀”指除了第一个字符以外，一个字符串的全部尾部组合构成的集合，必须从尾部开始。 Partial Match Table就是前缀和后缀的最长共有子串的长度 string prefix postfix partial match length “A” $\emptyset$ $\emptyset$ 0 “AB” [A] [B] 0 “ABC” [A, AB] [BC, C] 0 “ABCD” [A, AB, ABC] [BCD, CD, D] 0 “ABCDA” [A, AB, ABC, ABCD] [BCDA, CDA, DA, A] 1 “ABCDAB” [A, AB, ABC, ABCD, ABCDA] [BCDAB, CDAB, DAB, AB, B] 2 “ABCDABD” [A, AB, ABC, ABCD, ABCDA, ABCDAB] [BCDABD, CDABD, DABD, ABD, BD, D] 0 现在我们得到了《部分匹配表》 search key A B C D A B D PML 0 0 0 0 1 2 0 当D和_不匹配时，已匹配的子串”ABCDAB”的部分匹配值是2，那么search key向后移动4位 1移动位数 = 已匹配的字符数 - 对应的部分匹配值 // 4 = 6 - 2 123BBC ABCDAB ABCDABCDABDE | ABCDABD 此时C与_不匹配，search key向后移动2-0=2位 123BBC ABCDAB ABCDABCDABDE | ABCDABD 因为_与A不匹配，继续后移一位。 123BBC ABCDAB ABCDABCDABDE | ABCDABD 以此类推~ 计算PMT123456789void makenxt(string&amp; P, vector&lt;int&gt;&amp; nxt) &#123; int len = P.length(); for(int i = 1, l = 0; i &lt; len; i++) &#123; while(l &gt; 0 &amp;&amp; P[l] != P[i]) l = nxt[l-1]; if(P[l] == P[i]) l++; nxt[i] = l; &#125;&#125; 以下引用c_cloud的解释 已知前一步计算时最大相同的前后缀长度为k（k&gt;0），即P[0]···P[k-1]； 此时比较第k项P[k]与P[q],如图1所示 如果P[K]等于P[q]，那么很简单跳出while循环; 关键！关键有木有！关键如果不等呢？那么我们应该利用已经得到的next[0]···next[k-1]来求P[0]···P[k-1]这个子串中最大相同前后缀，可能有同学要问了——为什么要求P[0]···P[k-1]的最大相同前后缀呢？？？是啊！为什么呢？ 原因在于P[k]已经和P[q]失配了，而且P[q-k] ··· P[q-1]又与P[0] ···P[k-1]相同，看来P[0]···P[k-1]这么长的子串是用不了了，那么我要找个同样也是P[0]打头、P[k-1]结尾的子串即P[0]···Pj-1，看看它的下一项P[j]是否能和P[q]匹配。如图所示 Full code 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void makenxt(string&amp; P, vector&lt;int&gt;&amp; nxt) &#123; int len = P.length(); for(int i = 1, l = 0; i &lt; len; i++) &#123; while(l &gt; 0 &amp;&amp; P[l] != P[i]) l = nxt[l-1]; if(P[l] == P[i]) l++; nxt[i] = l; &#125;&#125;void kmp(string&amp; S, string&amp; P) &#123; vector&lt;int&gt; nxt(P.length(), 0); makenxt(P, nxt); for(auto i : nxt) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl; for(int i = 0, j = 0; i &lt; S.length(); i++) &#123; while(j &gt; 0 &amp;&amp; P[j] != S[i]) j = nxt[j-1]; if(P[j] == S[i]) j++; if(j == P.length()) &#123; cout &lt;&lt; "Pattern starts with idx: " &lt;&lt; i-P.length()+1 &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; "Not Found" &lt;&lt; endl;&#125;int main() &#123; string S = "BBC ABCDAB ABCDABCDABDE"; string P = "ABCDABD"; kmp(S, P); return 0;&#125; Sunday 算法Here’s a string “substring searching”，I wanna know，if it contains another string “search”. 123substring searching |search 第2个字符不匹配，这个时候我们关注source string中末位对齐位置的下一个字符，即字符i，i不在search string中，那么以下几种位置都是不可能匹配的，因为i的存在 12345678910111213substring searching ||||||||||| search||||| |||||||||| search|||| ||||||||| search||| |||||||| search|| ||||||| search| |||||| search 因此，将search string向后移动m+1位（m是search key长度），如下所示 123substring searching |||||| search 此时，第一个字符不匹配，再看末位对齐位置的下一个字符，即字符r，r在search string中，那么向后移动search string6 - 3 = 3位，使得source string中r与search string中最后一个r对齐 123substring searching |||||| search Shift table《偏移表》是针对source string建立的，而《部分匹配表》是针对search string建立的 shift[c]= \begin{cases} m-max\{i]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>next</tag>
        <tag>kmp</tag>
        <tag>sunday</tag>
        <tag>string</tag>
        <tag>match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-OJ]]></title>
    <url>%2Fpost%2F4c3ebdcd.html</url>
    <content type="text"><![CDATA[Everyday programing ! See solutions on My LeetCode 1. Two Sum BF with binary search 哈希表T = O(N) S = O(N) 建立value-index映射 依次遍历，如果另一半在map中，返回当前下标i和map[另一半]；反之将当前&lt;value, index&gt;插入map 2. Add Two Numbers 两数相加，两数用链表形式表示 3. Longest Substring Without Repeating Characters 滑动窗口[i, j] 每次向右滑动j，当遇到之前重复出现的字符c时，此时[i, j-1]区间没有重复的，i定位到max(i, 上一个c的位置+1)，此时[i, j]之间消除了重复字符c O(N) 4. Median of Two Sorted Arrays O(m+n) 类似于归并排序，对奇偶有不同的要求 5. Longest Palindromic Substring 给出一个字符串s，求s的最长回文字串的长度 dp[i][j]表示s[i]到s[j]所表示的字串是否是回文字串。只有0和1 递推方程： 当s[i] == s[j] : dp[i][j] = dp[i+1][j-1] 当s[i] != s[j] : dp[i][j] =0 边界i == j || j = i+1：dp[i][j] = 1, dp[i][i+1] = (s[i] == s[i+1]) ? 1 : 0 123for(int i = len - 1; i &gt;= 0; --i) &#123; for(int j = i; j &lt; len; ++j) &#123; if(s[i] == s[j] &amp;&amp; (j - i &lt; 3 || dp[i+1][j-1])) &#123; 上述判断可以解决边界的判断 6. ZigZag Conversion 储存为一个二维的vector，以不同的顺序遍历得到结果T = O(N) S = O(N) 通过计算位置依次遍历S = O(1) 7. Reverse Integer 通过计算反转 123456while(x) &#123; ret *= 10; ret += x % 10; if(ret &gt; INT_MAX || ret &lt; INT_MIN) return 0; x /= 10;&#125; 8. String to Integer (atoi) find_if、find_if_not搭配匿名函数很方便的 9. Palindrome Number 判断一半即可 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return false; int sum = 0; while(x &gt; sum) &#123; sum = sum * 10 + x % 10; x /= 10; &#125; return (x == sum) || (x == sum/10); &#125;&#125;; 10. Regular Expression Matching using C++11 \ 12regex r(p);return regex_match(s, r); dp 11. Container With Most Water Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don’t support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left 12. Integer to Roman 最多四位数，以数组的形式定义每个位的一个数字关于符号的映射 1234string M[] = &#123;"", "M", "MM", "MMM"&#125;;string C[] = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;;string X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;;string I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; 13. Roman to Integer 先建立字母-数字映射 从后往前读 当前位数字&gt;=已经读到的数字中的最大值，结果加上 反之，结果减去 14. Longest Common Prefix(LCP) 顺序比较：T = O(S) S = O(1) S is the sum of all chars Divide and conquer Binary search Prefix Trie(TODO) 以字符串排序，LSP(S1,S2,...,Sn)=LSP(S1, Sn) 15. 3Sum T = O(N*N) 从小到大排序，目的是方便剔除重复，因为当两个点固定时，第三个点可能重复的下标一定是连续的 1234567891011121314for(int i = 0; nums[i] &lt; 0; ++i) &#123; a = nums[i]; for(int j = i + 1, k = nums,size()-1; j &lt; k; ) &#123; b = nums[j]; c = nums[k]; sum = a + b + c; if(sum = 0) &#123; add to res; while(j &lt; k &amp;&amp; b == nums[++j]); // 重复的下标一定相邻 while(j &lt; k &amp;&amp; c == nums[--k]); &#125; else if(sum &gt; 0) k--; else j++; &#125;&#125; 16. 3Sum Closest 思路与15题类似，排序后采用双指针 1234567891011121314151617181920class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; long res = INT_MAX, sum; sort(nums.begin(), nums.end()); sum = nums[0]+nums[1]+nums[2]; for(int i = 0; i &lt; nums.size(); ++i) &#123; int a = nums[i]; if(i &gt; 0 &amp;&amp; a == nums[i-1]) continue; for(int left = i + 1, right = nums.size()-1; left &lt; right; sum &lt; target ? ++left: --right) &#123; int b = nums[left], c = nums[right]; sum = a + b + c; if(sum == target) return sum; if(abs(sum - target) &lt; abs(res - target)) res = sum; &#125; &#125; return res; &#125;&#125;; 17. Letter Combinations DFS 18. 4Sum 固定两个点，再采用双下标 19. Remove Nth Node From End of List tow pass T = O(2L - n) = O(L) S = O(1) 计算长度，两次遍历 one pass T = O(L) S = O(1) 双指针，指针之间的间隔是n+1 dummy头部保存head，遍历从dummy开始 20. Valid Parentheses stack 21. Merge Two Sorted Lists using dummy head 22. Generate Parentheses Backtracking 1234567891011121314151617void DFS2(vector&lt;string&gt;&amp; v, int lp, int rp, const int n) &#123; static string tmp; if(lp + rp == 2*n) &#123; v.push_back(tmp); return; &#125; if(lp &lt; n) &#123; tmp.push_back('('); DFS2(v, lp+1, rp, n); tmp.pop_back(); &#125; if(lp &gt; rp) &#123; tmp.push_back(')'); DFS2(v, lp, rp+1, n); tmp.pop_back(); &#125; &#125; Time and Space Complexity: $O(\frac{4^n}{\sqrt{n}})$ Closure Number 12345678910111213class Solution2 &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; if(n == 0) ret.push_back(""); else for(int c = 0; c &lt; n; ++c) for(auto left : generateParenthesis(c)) for(auto right : generateParenthesis(n-c-1)) ret.push_back("(" + left + ")" + right); return ret; &#125;&#125;; result = (+left+)+right = {, , } 23. Merge k Sorted Lists Merge one by one：k个链表，两两合并，合并k-1次 T = O(k*N)k是链表的数目 S = O(1) Compare one by one 维护一个大小为k的优先队列，每次push/pop比较的时间复杂度都是O(logK),k是链表的个数 依次出列，出列的指针的下一个节点入列，知道队列为空 T = O(Nlogk) S = O(k) Merge with Divide and Conquer T = O(Nlogk) S = O(1) 24. Swap Nodes in Pairs 维护三个指针，pre, curr, nxt 1234567891011121314151617class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *pre = dummy, *curr, *nxt; while(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next) &#123; curr = pre-&gt;next; nxt = curr-&gt;next; curr-&gt;next = nxt-&gt;next; nxt-&gt;next = curr; pre-&gt;next = nxt; pre = curr; &#125; return dummy-&gt;next; &#125;&#125;; 25. Reverse Nodes in k-Group 反转链表的变体：局部反转 先判断从当前head开始是否有k个结点 若有，则反转链表，记录反转后的尾部和下一个头部 若无，则用上一步的尾部之间连接头部，跳出循环 1234567891011121314151617181920212223242526ListNode *dummy = new ListNode(0);ListNode *pre = NULL, *nxt = NULL, *p = head, *end = dummy;while(head) &#123; int cnt = 0; while(p &amp;&amp; cnt &lt; k) &#123; p = p-&gt;next; cnt++; &#125; // 计算节点数 if(cnt &lt; k) &#123; // 结点数不足k end-&gt;next = head; // 上一步骤的end直接连接当前head，无需反转 break; &#125; else &#123; // 反之，局部反转 p = head; pre = NULL; // 这一步相当重要，否则会出现环 while(cnt--) &#123; nxt = p-&gt;next; p-&gt;next = pre; pre = p; p = nxt; &#125; end-&gt;next = pre; // pre就是局部反转之后的head end = head; // 保存局部反转之后的尾部 &#125; head = p; // 更新头&#125; recursive version 1234567891011121314151617181920class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || k &lt; 2) return head; ListNode *p = head; for(int i = 0; i &lt; k; ++i) &#123; if(p) p = p-&gt;next; else return head; &#125; ListNode *pre = NULL, *curr = head, *next = NULL; for(int i = k; i &gt; 0; --i) &#123; // while(curr != p) next = curr-&gt;next; curr-&gt;next = pre; pre = curr; curr = next; &#125; head-&gt;next = reverseKGroup(p, k); return pre; &#125;&#125;; 206. Reverse Linked List 维护三个指针，pre, curr, nxt 123456789101112131415class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *pre = NULL, *next = NULL; if(!head) return head; while(head-&gt;next) &#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; head-&gt;next = pre; return head; &#125;&#125;; 26. Remove Duplicates from Sorted Array 双下标 1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2) return nums.size(); int i = 0; for(int j = 1; j &lt; nums.size(); ++j) &#123; if(nums[j] != nums[i]) &#123; ++i; nums[i] = nums[j]; &#125; &#125; return i+1; &#125;&#125;; 27. Remove Element 同上 28. Implement strStr() 字符串匹配 see in 字符串匹配算法—KMP&amp;Sunday 29. Divide Two Integers 首先考虑overflow divisor == 0dividend == INT_MIN &amp;&amp; divisor == -1 主要思路就是做减法：每次只减去divisor，速度太慢，通过&lt;&lt;操作可以使得divisor乘2，如果dvd &gt;= (dvs &lt;&lt; 1)，那么quo &lt;&lt; 1 123456789while(dvd &gt;= dvs) &#123; long long tmp = dvs, quo = 1; while(dvd &gt;= (tmp &lt;&lt; 1)) &#123; quo &lt;&lt; 1; tmp &lt;&lt; 1; // 乘2加速 &#125; dvd -= tmp; ret += quo;&#125; 30. Substring with Concatenation of All Words map的应用：map储存每个单词出现的次数 每次从s中取word_len*words.size()长度的字符串，遍历其中的每个“单词”（由于单词长度固定，每次直接取出即可），map中的该单词计数减一，直到出现冲突即跳出]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-Advanced-Level]]></title>
    <url>%2Fpost%2F62ae0339.html</url>
    <content type="text"><![CDATA[Everyday programing ! See Solutions on My PAT 2018.9.8 PAT A Level 1001(字符串处理) string operation using insert insert function cannot accept reverse_iterator reverse the whole string, then do it as normal convert reverse_it to it (not try, maybe not work) 1str.insert(r_iter.base(), 1, ','); for each iteration, we should update iterator 1iter = str.insert(iter, ','); http://www.cplusplus.com/reference/string/string/insert/ 1002(两路merge) two-way merge 1003(Dijkstra算法 点带权) my code using priority queue 22/25 using Dij Algorithm to find shortest path using priority queue to find vertex to visit before push into queue, we need to find if the id in queue self-defined cmp function for determining priority 12345struct mycmp &#123; bool operator()(int i, int j) &#123; return s_dist[i] &gt; s_dist[j]; &#125;&#125;; using vector&lt;vector&lt;int&gt;&gt; store path 12345678910111213if(s_dist[curr] + dist[curr][i] &lt; s_dist[i]) &#123; s_dist[i] = s_dist[curr] + dist[curr][i]; team_cnt[i] = team_cnt[curr] + teams[i]; path_cnt[i] = path_cnt[curr]; path[i].clear(); path[i].push_back(curr);&#125;else if(s_dist[curr] + dist[curr][i] == s_dist[i]) &#123; if(team_cnt[i] &lt; teams[i] + team_cnt[curr]) team_cnt[i] = teams[i] + team_cnt[curr]; path_cnt[i] += path_cnt[curr]; path[i].push_back(curr);&#125; 1004(DFS, BFS, 层序遍历) simple DFS using map to represent tree Idea from https://blog.csdn.net/iaccepted/article/details/21289205 can be done by BFS need to record level info. when input 1level[sid] = level[id] + 1; 1005(字符串处理) string operation 1006(模拟，优先队列应用) using map&amp;priority_queue 加速方法：将id映射成独立的数字id，存入结构体数组，通过直接的数组访问与比较加速 1007(最大连续子序列之和) online algorithm O(N) 123else if(curr_sum &gt; max_sum || (curr_sum == 0 &amp;&amp; end == N - 1)) &#123; ...&#125; curr_sum == 0 &amp;&amp; end == N - 1 is very important, for input as below: 12&gt;6&gt;0 0 0 0 -1 0 If this condition is omitted, the end is 5(that is N -1), which is incorrect. v2中调整了两个判断的顺序，思路简单了许多，关键点在于将maxSum初始化为负数，这样一来，+0也可以得到记录，输出时判断正负即可 1008(数学问题) simple 1009(模拟，map应用) using map 1010(二分法) simple for iteration cannot pass test point 7(large sum and out of time) binary search must consider N2_d &lt; 0 This situation happens when N1_d is very large, when computing N2_d, N2_d may exceeding the upper bound and become negative.(e.g. right is super large , so mid is also super large, calculate pow() can be super super large) 1234if(N2_d &gt; N1_d || N2_d &lt; 0) break;...else if(N2_d &gt; N1_d || N2_d &lt; 0) right = mid - 1;... idea from https://www.cnblogs.com/weedboy/p/7244819.html 还有一个非常重要重要地方 判断N2_d &lt; 0（溢出）一定要在判断N2_d &lt; N1_d前，不然误以为小于，其实是溢出造成的大于 1011(查找元素，优先队列应用) priority queue 1012(排序) sort grades rather than sort ID 88 87 87 55，the rank is 1,2,2,4 1013(图的遍历，DFS统计连通分量的个数) Find the # of sub-connected component连通分量的个数 DFS or BFS 不能用并查集，这是实际连接，不是虚拟连接 1014(queue应用，模拟) defining a good data structure is vital important. 这道模拟题中顾客是已经全部都在队列中的了 1015(素数，计算reverse number) is_prime 12345678bool is_prime(long x) &#123; if(x &lt; 2) return false; if(x == 2 || x == 3) return true; for(long i = 2; i*i &lt;= x; i++) &#123; if(x % i == 0) return false; &#125; return true;&#125; calculate reverse number 1016(排序) a good data structure understanding no two records for the same customer have the same time, 所以按时间排序后，offline时间和它正前方的online时间一定是一对 1017(queue的应用，模拟) the same as 1014 1018(Dijkstra 算法，DFS搜索最优路径，点带权，判定方法不同，多路径储存) 先得到所有路径，再DFS找到最优，因为不满足最优子结构 1019(回文数，字符串处理) simple 1020(树的遍历，之间的转换) the relationship between three traversal order 后续和中序构建层序 1021(图的遍历，DFS，计算连通分量的个数，Disjoint set) 通过DFS和Disjoint set都可判断连通分量的个数 而找到最深根有非常tricky的做法, 不用对每个节点DFS计算深度 先从一个结点dfs后保留最高高度拥有的结点们，然后从这些结点中的其中任意一个开始dfs得到最高高度的结点们，这两个结点集合的并集就是所求 Idea from https://www.liuchuo.net/archives/2348 这其实是一个逆向思维，最深叶子就当然是最深的root 1022(map应用) map的简单应用 对于连续getline(cin, s)操作,s是string 连续getline()操作之前一定要getchar()吃掉回车 连续getline()操作之间没有其他输入输出则不用getchar() 连续getline()操作之间有cout/printf输出'\n'，则不用getchar() 1023(大整数运算，字符串操作) 大整数运算，通过string以及字符操作来实现 最后的进位要考虑到 判断方法tricky 123sort(origin.begin(), origin.end());sort(res_copy.begin(), res_copy.end());if(res_copy == origin) //Yes 1024(大整数运算，字符串实现) 大整数运算，通过string以及字符操作来实现 1025(排序) Test 3 timeout可能原因是使用map映射id和各种信息，红黑树查找需要时间，不如vector直接快 直接定义结构体就好了 1026(模拟，queue应用，数据结构设计) TODO: re-define data structure, and simulate the queueing 1027(进制转换) easy 1028(排序) scanf&amp;printf is faster 1029(排序，边读边排) 第一个队列存好后，把第二个队列边读，边和第一个队列比较，选择出队。这样可以不用一次存完第二个队列，解决超内存的问题. Idea from https://www.liuchuo.net/archives/2248 a.push(INT_MAX);b.push(INT_MAX);保证了a、b不会为空 1030(Dijkstra算法 + DFS，最短路径，边带权) vector&lt;int&gt; path储存前驱 1031(字符串操作，数学问题) $2x+y-2=N\to x = \frac{N+2-y}{2}$, 目的是为了$y-x$大于0且最小，$y-x=\frac{3y-N-2}{2}$只能等于$i,i\in{0,1,2,..}$，遍历i，解得y即可 1032(数组形式链表) 1033(贪心) 1034(DFS，有向图遍历，map应用) 内存有限，时间有限，给所有的id(string)分配连续的index下标，降低空间要求，同时数组操作更快 DFS遍历有向图，实际上是遍历每条边，所以只有当该点为起点，并且没有访问过时，计入以他为起点的边。 1035(字符串操作) while((c = getchar()) != '\n') 1036(排序、查找) online 边读边比较 1037(排序，求和) 忽略0 1038(贪心？字符串比较) cmp: return a + b &lt; b + a 满足最优子结构 1039(映射，大数据查找) 简单map会超时，改用vector执行映射，首先要建立ID与下标的关系——getid() getid()中pow函数会降低效率... 1040(DP最长公共子串LC-Substring) TODO：LC substring &amp; LC subsequence 转移方程 $C[i][j] = C[i == 0?0:i-1][j ==0?0:j-1] + 1\quad when\quad s1[i]==s2[j]$ $C[i][j] = 0\quad when \quad s1[i]\neq s2[j]$ 上述转移方程是错误的 对于aacdefcaa，输出是aac 正确的DP 给出一个字符串s，求s的最长回文字串的长度 dp[i][j]表示s[i]到s[j]所表示的字串是否是回文字串。只有0和1 递推方程： 当s[i] == s[j] : dp[i][j] = dp[i+1][j-1] 当s[i] != s[j] : dp[i][j] =0 边界情况是当长度为1或2时：dp[i][j] = 1, dp[i][i+1] = (s[i] == s[i+1]) ? 1 : 0 123456789101112int len = s.length();vector&lt;vector&lt;bool&gt; &gt; dp(len, vector&lt;bool&gt;(len, false));for(int i = len - 1; i &gt;= 0; --i) &#123; for(int j = i; j &lt; len; ++j) &#123; if(s[i] == s[j] &amp;&amp; (j - i &lt; 3 || dp[i+1][j-1])) &#123; dp[i][j] = true; if(j - i + 1 &gt; res.length()) res = s.substr(i, j - i + 1); &#125; &#125;&#125;return res; string.substr()中两个参数一个是起始下标，一个是长度 1041(queue应用，Hash散列) 第一次见到的入队，出现过两次以上的标记为seen，再从队列顶部查看，如果seen，则出队，找到第一个非seen标记即为所求 1042(排序) 计算最终的位置即可 1043(树遍历以及之间的关系) 通过前序中序构建后序，并通过结构判断是否是BST 1044(二分法，查找) 遍历起始下标i，找到最小的j，使得i-j的总价钱是正好&gt;=M 通过二分加速 储存diamond方式与1046类似，降低空间复杂度 1045(LC-Subsequence) 此题是LCS的变体，在保持顺序的前提下，允许重复 $C[i][j] = max(C[i][j-1], C[i-1][j])\quad when\quad s1[i] \neq s2[j]$ $C[i][j] = max(C[i][j-1], C[i-1][j])+1\quad when\quad s1[i] = s2[j]$ 1046(模拟，online边读入边计算) 只需要储存某一个定点到其他所有点的距离，任意两点的距离都是abs(定点到这两点的距离之差) 注意顺序储存 最后比较这个距离和另一条路的距离(环路总距离 - 一条路的距离) 1047(1039的逆过程，大数据查找) easy 1048(查找，二分查找) 调用binary_search 1049(数学问题) now表示当前位，left表示当前位左边所有数字构成的数字，right表示当前位右边所有数字构成的数字，用a表示now对应的位制，a=1说明now在个位，a=10说明now在十位 如果now是0：会产生left*a个1，因为只有在left从0~left-1的时候产生1，所以产生了left个，又因为右边会重复a次（0~a-1） 如果now是1：要比上一种情况多产生 当now为1时，right从0~right所增加的right+1个1 如果now大于1：会产生(left+1)*a个1，因为只有在left从0~left的时候产生1，所以产生了left个，又因为右边会重复a次（0~a-1） now从最低位到最高位依次迭代 更好的解释 假设N=abcde，这里a、b、c、d、e分别是十进制数N的各个数位上的数字。如果要计算百位上出现1的次数，它将会受到三个因素的影响：百位上的数字，百位以下（低位）的数字，百位（更高位）以上的数字。 如果百位上的数字为0，则可以知道，百位上可能出现1的次数由更高位决定，比如12 013，则可以知道百位出现1的情况可能是100～199，1 100～1 199，2 100～2 199，…，11 100~11 199，一共有1 200个。也就是由更高位数字（12）决定，并且等于更高位数字（12）×当前位数（100）。 如果百位上的数字为1，则可以知道，百位上可能出现1的次数不仅受更高位影响，还受低位影响，也就是由更高位和低位共同决定。例如对于12 113，受更高位影响，百位出现1的情况是100～199，1 100～1 199，2 100～2 199，…，11 100~11 199，一共1 200个，和上面第一种情况一样，等于更高位数字（12）×当前位数（100）。但是它还受低位影响，百位出现1的情况是12 100～12 113，一共14个，等于低位数字（13）+1。 如果百位上数字大于1（即为2~9），则百位上可能出现1的次数也仅由更高位决定，比如12 213，则百位出现1的可能性为：100～199，1 100～1 199，2 100～2 199，…，11 100～11 199，12 100～12 199，一共有1 300个，并且等于更高位数字+1（12+1）×当前位数（100）。 1050(字符操作，字符串操作) 可见字符共95个，算上' '(空格) gets()为啥编译错误 1051(栈模拟，出栈序列判断) 方法一：从最先出栈的元素开始遍历 当前出栈元素位A，所有在A后面出栈并且小于A的元素必须从大到小 连续从大到小出栈的个数不能超过栈大小 方法二：模拟入栈出栈过程 保存输入的序列到数组 顺序将1~n进栈 如果大小超过栈大小，break 设current = 1，从保存数组的第一个数字开始，判断是否与栈顶元素相等，相等则出栈current++，不相等就继续按顺序把数字压入栈 1052(链表) 不在链表中要去除 链表为空输出0 -1 通过map或者vector映射链表，vector所需空间大 1053(树遍历，DFS) 先对儿子节点按照权排序，之后顺序遍历即可 1054(map的应用) map：$color\mapsto 出现的次数$ 1055(排序) 简单排序，遍历输出，达到计数要求退出 加速的方法：n有10的5次方，m却只有100个，储存所有年龄按照题目要求排序后的前100名，得到的数组再进行遍历 我自己又把问题想复杂了，先按年龄排序，然后二分查找，找到范围，再按照题设排序 1056(模拟，排序，priority_queue) seq数组储存每一轮的出场顺序，符合下一轮条件的push_back到末尾，最后删出原来所有的元素，进入下一轮 通过priority_queue选出小组中最大的下标 1057(BIT树状数组) c[x]表示$\le x $的数出现的个数 求第k = (S.size() + 1)/2大的数，就是求从小到大的第K个数，即查找第一个x，使得小于等于x的数的个数等于K 二分法加速 12345678910int PeekMedian() &#123; int left = 1, right = maxn, mid, k = (s.size() + 1) / 2; while(left &lt; right) &#123; mid = (left + right) / 2; if(getsum(mid) &gt;= k) right = mid; else left = mid + 1; &#125; return left;&#125; 1058(进制转换) long long Galleon的base取LLONG_MAX 1059(生成素数表) prime_tab 12345#define RANGE 500000for(long i = 2; i*i &lt; RANGE; i++) for(long j = 2; j*i &lt;= RANGE; j++) prime_tab[j*i] = false;fill(prime_tab.begin(), prime_tab.begin() + 2, false); 1060(科学计数) 字符串处理 找到第一个非零数字位置和小数点的位置（无小数点，则小数点位置默认在数末尾），两者之差就是幂指数 1061(字符串处理) easy 1062(排序) priority_queue重载&lt;号 或者vector排序，自定cmp函数 1063(Set应用) 简单查找 1064(完全二叉树，CBT) 具有唯一性 根据已排序的节点，节点个数为N，找到根的下标 计算相同高度的“半满完全二叉树”的节点数 bound= (upper+low) / 2，upper和low是相邻两完美二叉树的节点数 若大于bound，则第upper/2 + 1个节点就是根 若小于等于bound，则第N - low/2个节点就是根 递归进行 根与儿子在level序遍历中下标的关系 left = root*2+1 right = root*2+2 1065(大数相加，判断越界) MAX + MAX = -2 MIN + MIN= 0 1066(AVL tree) 核心函数 get_height(Node* root) Insert(Node *root, int key) RR(Node *root)、LL(Node *root)、LR(Node *root)、RL(Node *root) 1067(模拟，贪心) 记录数字i在输入中的下标pos[i]，即i保存在pos[i]的位置 输入时，用cnt记录没有在对应位置的数的个数，cnt就为迭代次数 0不在0位，如果在pos[0]位，该位置本应该是数pos[0]，而数pos[0]的位置在pos[pos[0]]，将这两个位置交换 0在0位，当前序列不是有序的，就把0和第一个没有在对应位置的数进行交换 如果每次从头开始找很浪费时间。对于上一次查找，我们记录下标pre_k，说明pre_k以前的一定是排序好的，下一次就从pre_k开始就好了 v2是这一思想的紧凑实现，非常厉害 1068(01背包问题Knapsack problem) v1空间压缩，v2没有空间压缩，19/30错误的回溯方法 回溯关键，物品size降序排列 该问题具有一定的特殊性，价值==size（价值与size成正比） 递推关系：m(i, j)表示背包容量为 j，面对物品 i 所能获得的最大value 1234if(j&gt;=w[i]) m[i][j]=max(m[i-1][j], m[i-1][j-w[i]] + v[i]);else m[i][j]=m[i-1][j]; 获得的最大价值all i, max(m[i][C])```，通常是```max[N][C]```12345678910111213141516171819202122232425- 要得到选了那些物品，需要从矩阵右下角开始traceback - **&lt;u&gt;只能获得一个解，这一个解与物品选取的顺序有关，当然所有解总是不变的&lt;/u&gt;** ```c++ //用二维数组储存, N是item数，Capacity是背包容量,choice数组记录选择 vector&lt;int&gt; res; void traceback() &#123; int C = Capacity; for(int i = N; C &gt; 0; i--) &#123; if(m[i][C] == m[i-1][C-w[i]] + w[i]) &#123; res.push_back(w[i]); C -= w[i]; &#125; &#125; &#125; //while的写法 while(C &gt; 0) &#123; if(DP[i][C] == DP[i-1][C-w[i]]+w[i]) &#123; res.push_back(w[i]); C -= w[i]; &#125; i--; &#125; 空间优化 12345678910vector&lt;int&gt; DP(M + 1, 0);vector&lt;vector&lt;bool&gt; &gt; choice(N + 1, vector&lt;bool&gt;(M + 1, false));//用choice回溯for(int i = 1; i &lt;= N; i++) &#123; for(int j = M; j &gt;= weight[i]; j--) &#123; if(DP[j] &lt;= DP[j - weight[i]] + weight[i]) &#123; DP[j] = DP[j - weight[i]] + weight[i]; choice[i][j] = true; &#125; &#125;&#125; 1069(数学问题) 注意输入和计算过程补0 stoi真好用 1070(简单贪心) 1071(map的应用) 如果已经读到换行符，若token不为空，跳出while之后还要将这个token加上 1072(Dijkstra算法) 熟悉Dij的代码块 123456789101112131415161718fill(d.begin(), d.end(), INF);fill(visited.begin(), visited.end(), false);d[src] = 0;for(int i = 1; i &lt;= N; i++) &#123; int u = -1, min = INF; for(int j = 1; j &lt;= N; j++) &#123; if(!visited[j] &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) break; visited[u] = true; for(int v = 1; v &lt;= N; v++) &#123; if(!visited[v] &amp;&amp; e[u][v] != INF &amp;&amp; d[u] + e[u][v] &lt; d[v]) d[v] = d[u] + e[u][v]; &#125;&#125; 1073(字符串操作，科学计数法) 1074(链表数组表示，分组) 1075(排序) 拿到满分的题目数统计时，如果有多次相同题目的满分提交，要判断取最大值之前是不是已经满分了，如果已经满分了，满分题目数不再增加 1076(BFS, queue的应用) 用队列实现，某一层在队列中，依次出列，出列元素对应的下一层入列，通过记录操作前队列的大小（即pop的次数），可以使得下一层入列之后，之前层都出列了 1077(字符串操作) getline(cin, string) 判断是否已经为空串 1078(hash二次探测法) 函数函数一般为h(key) = key % size; if idx = H(key) 可以插入，则插入 else idx = H(key + i*i) for i = 0,1,...,size-1 1079(树的遍历，DFS or BFS) 1080(排序) 区分下标与打印时的ID是不是同一个东西 1081(gcd，分数相加模拟) 浮点错误应该考虑程序中： 是否可能出现了一个数除以0的情况 是否可能出现了一个数取余0的情况 是否发生了数据溢出而导致的除以0或者取余0的情况 1082(字符串操作) 1083(简单排序) 1084(简单字符串操作) 1085(二分法，查找) 复杂度O(nlogn) 熟练使用upper_bound() 也可解决问题，复杂度为O(N) 12for(int i = 0; i &lt; N; i++) res = max(res, upper_bound(arr.begin(), arr.end(), arr[i]*p) - (arr.begin()+i)); 1086(树的遍历之间的关系) 前、中 推出 后 1087(Dijkstra+路径保存+DFS搜索最优路径) 与1018类似 1088(分数四则运算，字符串操作) 注意判断符号 1089(插入排序，Merge Sort，判断与模拟) 本解答提供了一种判断当前merge sort步长的方法 提供了一种伪模拟的方法 1090(简单DFS) 1091(BFS，三维方向) BFS 其实也是计算连通分量的个数，或许能用并查集实现，将三位数组化成一数组idx = 100*i+10*j+k 1092(字符串处理) 1093(字符串处理) Pcnt、PAcnt、PATcnt，online可以解决 1094(DFS, BFS，树遍历) BFS用queue实现 1095(模拟difficult) 配对要求是，如果一个车多次进入未出，取最后一个值；如果一个车多次out未进入，取第一个值。 注意：一个车可能出入校园好多次，停车的时间应该取之和。 为了简便，应该把小时和分钟都化简成秒数计算比较方便。 一开始所有车辆的id、时间和是进还是出（进的flag是1，出的flag是-1），对他们排序，先按照车牌号排序，再按照来的时间先后排序。 此后就能根据这样的排序后的顺序将所有满足条件（合法）的车辆进出记录保存到另一个数组里面。这个数组再按照时间先后排序。 因为多次询问值，为了避免超时，可以把他们的车辆数carcnt数组先算出来。到时候直接取值就会比较快速。carcnt[i]表示在i下标的记录的时间点的时候车辆的数量。数量可以由前一个数量+当前车辆的flag得到。 因为问询的时候是多个时间点按照从小到大的顺序，利用好这点能避免超时。如果上一个查询的index已经被记住，那么下一次就只需要从这个index开始找就可以了，避免重复寻找，浪费时间。 1096(循环，逻辑题) 对素数直接输出加速 1097(链表，类似题1032、1052、1074) 1098(Insertion sort、Heap sort判断与模拟) make_heap、pop_heap用来模拟Heap sort 1099 二叉搜索树，中序遍历是升序，模拟中序遍历即可插入key，之后层序遍历即可 1100(字符串处理) 1101(quick sort) 对原序列sort排序，逐个比较，当当前元素没有变化并且它左边的所有值的最大值都比它小的时候就可以认为它一定是主元（很容易证明正确性的，毕竟无论如何当前这个数要满足左边都比他大右边都比他小，那它的排名【当前数在序列中处在第几个】一定不会变）。 1102(层序遍历，中序遍历) 1103(DFS+剪枝，用数组储存幂值加速) 由于结果要求序列最大同时和最大，因此从大到小枚举，下一层枚举值不能超过上一层枚举值，保证了序列和最大的同时，序列最大 将当前和作为参数传入下一层，而不是在最后一层遍历相加，依次加速 12345for(int i = tmp.empty() ? floor(pow(num, 1.0/P)) : tmp.back(); vfactor[i] &gt;= 1; i--) &#123; tmp.push_back(i); if(num &gt;= vfactor[i]) KP(num - vfactor[i], depth + 1, sum+i); tmp.pop_back();&#125; pow(i, P)提前计算，存在vfactor[i]，减少搜索中不必要的计算 12for(int i = 1, tmp = 0; tmp &lt;= N; tmp = pow(i, P), i++) vfactor.push_back(tmp); 1104(数学问题) 1105(数学问题) 顺时针螺旋填入矩阵 1106(BFS) 1107(并查集) 1108(字符串处理) 1109(排序后指定输出) 1110(BFS, 完全二叉树判断) 1111(Dijkstra，路径选择) 路径选择可以保存二维数组，DFS选择路径 也可以记录到达每个节点时的判定值，直接选择 1112(字符串操作) 注意细节呀细节：当输入的长度小于k的情况；当剩余未遍历字符数少于k的情况 12345if(line.length() - i &lt; k) &#123; isbroken[toascii(line[i])] = false; i++; continue;&#125; 1113(排序) so easy 1114(并查集) 1115(BFS，建立BST) easy 1116(简单逻辑题) 1117(逻辑题，难看懂题目,排序) N天中有E天骑行的距离超过E，求最大的E 1118(简单并查集) 1119(树遍历之间的转换，前序后序转中序) 首先我们需要知道树的表示范围，需要四个变量，分别是前序的开始的地方preLeft，前序结束的地方preRight，后序开始的地方postLeft，后序结束的地方postRight 前序遍历的第一个与后序遍历最后一个是根节点 以后序遍历最后一个(根节点)节点的前一个节点val为基准，寻找这个节点在前序中的位置 如果val在前序中正好在前序中第一个节点(根节点)的后面，那么根节点只有一颗子树，子树的根节点是val，那么正是这种情况无法确定val是在根的左边还是右边，flag=false，并规定它总是为右节点 如果在前序中val和preLeft(根节点)直接还有节点，说明这个val是根的右儿子，前序中根节点和val之间的节点都是左子树，对应在后序中就是从postLeft开始的相同个数的节点，右子树就是前序中包括val，到preRight的所有节点，对应后序中就是去掉前面那些左子树的节点到包括postRight-1这些节点 1120(简单题) 1121(数组map，简单题) 1122(哈密尔顿回路判定) 连通性判断 12345678int isConnected() &#123; int pre = v[0]; for (int i = 1; i &lt; kn; i++) &#123; if (graph[pre][v[i]] != 1) return 0; pre = v[i]; &#125; return 1;&#125; 连通之后只需判断访问次数即可 123456789int isHamilt() &#123; if (v[0] != v[kn-1]) return 0; vector&lt;int&gt; times(kn, 0); for (int i = 0; i &lt; kn; i++) times[v[i]]++; for (int i = 1; i &lt; kn; i++) if ((i == v[0] &amp;&amp; times[i] != 2) || (i != v[0] &amp;&amp; times[i] != 1)) return 0; return 1;&#125; 1123(AVL tree，层序遍历) 123456789101112131415161718Node *Inster(Node *root, int key) &#123; if(root == NULL) &#123; root = new Node(); Node-&gt;key = key; Node-&gt;left = Node-&gt;right = NULL; &#125; else if(key &lt; root-&gt;key) &#123; root-&gt;left = Insert(root-&gt;left, key); if(get_height(root-&gt;left) - get_height(root-&gt;right) == 2) root = key &lt; root-&gt;left-&gt;key ? LL(root-&gt;left) : LR(root-&gt;right); &#125; else &#123; root-&gt;right = Insert(root-&gt;right, key); if(get_height(root-&gt;right) - get_height(root-&gt;left) == 2) root = key &lt; root-&gt;left-&gt;key ? RL(root-&gt;left) : RR(root-&gt;right); &#125; return root;&#125; 1124(map，简单逻辑题) 遍历一遍即可 1125(简单逻辑题) 1126(欧拉回路，半欧拉路径判定) DFS判定连通性 123456789101112131415void dfs(int index) &#123; visit[index] = true; cnt++; for (int i = 0; i &lt; v[index].size(); i++)//邻接表 if (visit[v[index][i]] == false) dfs(v[index][i]); /* for(int i = 1; i &lt;= N; i++) &#123;//邻接矩阵 if(!visited[i] &amp;&amp; e[u][i] == 1) DFS(i); &#125; */&#125;dfs(1);cnt为n是连通的 连通无向图：|E|&gt;=|V|-1 1127(post order+in order =&gt; level order zigzag输出) 其实只是在输出时增加判断改变顺序即可，每一层记录一个low index和high index，交替从low到high和从high到low 1028(逻辑题，判断 N Queens Puzzle) 对角线判断只需要判断横坐标和纵坐标的差是否出现过 1129(逻辑题，也可以用set重载&lt;来做) 每次更新选出top k，那我就用k+1大小的数组，每次更新若已在数组中，不操作，若不在则放置在最后一位，因为前k位只会与当前更新的这一个值和它们自己相关，在调用sort函数即可 set的做法https://www.liuchuo.net/archives/3848 不推荐，很容易用错 1130(树中序遍历) 1234567res = res + "(";if(Tree[root].left != -1) inorder(Tree[root].left);res = res + Tree[root].o;if(Tree[root].right != -1) inorder(Tree[root].right);res = res + ")"; 最后输出的时候从begin()+1到end()-1 注意判断一下res字符串的长度 1131(DFS) 1132(字符串操作) 注意除以0 1133(数组式链表) 1134(判断是否为顶点覆盖) 邻接矩阵表示边 某一个点a被选中，若边没有被选中e[a][b] = e[b][a] = true，计数cnt增加1，cnt==M时，说明全部覆盖 给边编号，用二维vector记录每个点连接了哪些边 比如a b两个结点构成的这条边的编号为0，则v[a].push_back(0)，v[b].push_back(0)——表示a属于0号边，b也属于0号边 1135(判断红黑树) 由于是二叉查找树，所以中序已知 已知前序和中序，转换成level序，可以通过index遍历 judge1判断红节点的儿子是否满足 judge2判断某节点到叶子，黑色节点的个数是否相同 要细心，每次level数组都要初始化，漏掉了这一点，这个bug找了两三个小时 也可以直接建树 1136(字符串模拟整数相加) 1137(map应用，排序) 1138(前序+中序转后续，树的遍历转换) 1139(模拟，细节题) -0000无法根据读取整数判断性别，需要用字符串读取 A在寻找同性朋友时，要避免找到TA想要的伴侣，B亦如此 1140(字符串处理) 1141(map引用非滥用，排序) 排序是若通过map找到数据进行比较会很慢，我们可以构造DATA结构保存数据，通过结构体内直接比较，减少时间 1234567891011bool cmp(string &amp;a, string &amp;b) &#123; if(TWS[a].first != TWS[b].first) return TWS[a].first &gt; TWS[b].first; else if(TWS[a].second != TWS[b].second) return TWS[a].second &lt; TWS[b].second; else return a &lt; b;&#125;//显然后者更快bool cmp(DATA &amp;a, DATA &amp;b) &#123; if(a.tws != b.tws) return a.tws &gt; b.tws; else if(a.Ns != b.Ns) return a.Ns &lt; b.Ns; else return a.name &lt; b.name;&#125; 1142(最大团判断Clique) 1143(找到最深相同根节点 LCA) 遍历的前序性保证了结果 1144(map简单使用) 思路简单 1145(hash，二次探测法) key+i*i % Size; i = 0, 1, 2, ..., Size-1 1146(拓扑序列判断) 定义在一种偏序下的全排列 每次选区入度为0（没有前驱）的节点，删除与该节点相连的边（或者把这个节点disable掉） pre[][]邻接矩阵记录前驱信息，如果当前输出有enable（没选或者之前没出现）的前驱（即入度不为0），那么该序列不是拓扑序列 1147(判断堆，树的遍历) 完全二叉树层序遍历转后序遍历 判断最大最小堆 1148(逻辑题，模拟) 首先狼人的个数是确定的2人，狼人中有一人说谎，平民中有一人说谎，同时要输出最小序列，那么直接从从到达枚举，一旦没有冲突，就找到了答案 先确定两个狼人 12345678910111213for(int i = 1; i &lt;= N-1; i++) &#123; for(int j = i + 1; j &lt;= N; j++) &#123; // i, j 就是狼人，其余为人，记住这是事实 for(int k = 1; k &lt;=N; k++) &#123; // 逐个检查它们说的话，分别记录两方说谎人数 &#125; if(两方说还人数都是1人) &#123; // 找到了 break; &#125; &#125; if(找到了) break；&#125; 1149(逻辑题) 注意一种气体可能与多种气体不相容，要用vector保存 类似于 Damn single 1150(逻辑题，判断TSP回路) 弄清判断条件即可 TSP simple : 遍历所有点，起始点=终止点，n = N+1 TSP circle: 遍历所有点，起始点=终止点 Non TSP : 遍历不全或不是circle 1151(类似于1143LCA) 加速方法：用map记录中序各个元素的下标，省去每次的查找 注意可能有负数，不能直接数组表示seen，要用map 依次遍历前序，找到第一个pre[i]在中序中的位置在a和b之间或者就是a或b]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ZJU-PAT</tag>
        <tag>OJ</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to build this blog using Hexo and GitHub Pages]]></title>
    <url>%2Fpost%2F3ace9508.html</url>
    <content type="text"><![CDATA[Tools Markdown：文章编写，内置层级、列表、超链接、图片插入、代码、数学公式等语法支持 Hexo：博客构建，快速搭建生成预览、发布 GitHub Pages：使用GitHub Pages托管，免费 Environment Node.js 1$ npm config set registry https://registry.npm.taobao.org # change source Hexo 12345$ npm install -g hexo-cli$ cd Blogs/ # your own file folder$ hexo init # initialize$ hexo install # or npm install# then u can generate an example 常用命令见Cheating Sheet Git Using NexT theme 下载主题 12$ cd &lt;your-hexo-site&gt;$ git clone https://github.com/theme-next/hexo-theme-next themes/next 启用主题 编辑_config.yml 1theme: next # 冒号后面有一个空格 设置语言 编辑_config.yml 123theme: - zh-Hans # -后面有一个空格- en Deploy GitHub Pages 在自己的GitHub账号下创建username.github.io的repo 设置SSH，详情参考廖雪峰的GIt教程 安装git-deploy插件 1$ npm install hexo-deployer-git -–save 关联仓库：编辑_config.yml 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 部署 1$ hexo g -d Binding your Domain name 购买域名 等待实名认证 解析域名 1$ ping &lt;usrename&gt;.github.io # get ip addr 配置如下2条 记录类型A主机记录@记录值ip-addr 记录类型CANME主机记录www记录值username.github.io 在hexo-site/source/中新建CNAME（无后缀名） 1&lt;your-domain-name&gt; # 加不加www看个人喜好 等待DNS生效 Hexo Configuration 头像：在\hexo-site\themes\next\_config.yml中设置avatar: &lt;avatar-url&gt; 可以放在\hexo-site\themes\next\source\images中直接引用url: /images/avatar.png 添加tag页面 1$ hexo new page tags 编辑source/tags/index.md 1234---type: "tags"comments: false--- 编辑themes/next/_config.yml 12menu: tags: /tags 新建categories页面，同上 新建about页面，同上，编辑这个md文件就可以自我介绍了 首页文章显示摘要&lt;!--more--&gt; 显示文章更新时间、创建时间以及其他总结信息 编辑themes/next/_config.yml 12345678# Post meta display settingspost_meta: item_text: true created_at: true updated_at: enabled: true another_day: true categories: true 显示文章统计信息 编辑themes/next/_config.yml注意注释中的依赖 12345# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true 代码块复制按钮、高亮 编辑themes/next/_config.yml 12345678# Add copy button on codeblockcopy_button: enable: true...# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 打赏信息 编辑themes/next/_config.yml 1234# Rewardreward_comment: You can buy me some snacks🍕🌭 ^_^wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 添加 Creative Commons 署名协议 编辑themes/next/_config.yml 12post_copyright: enable: true 字体设置在themes/next/_config.yml中的font字段 global全局字体 headings标头字体，就是h1,h2,h3...的字体 posts文章字体 logo左上角logo的字体Morning's blog codes代码快字体 评论区 注册livere账号 生成livere_uid：在Code Managing中复制如下代码到配置文件中themes/next/_config.yml 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: **********************== 本地关键词搜索 安装hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 编辑_config.yml 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml 12local_search: enable: true Fancybox For install 3.x: https://github.com/theme-next/theme-next-fancybox3 编辑themes/next/_config.yml 1fancybox: true 右侧社交栏 编辑themes/next/_config.yml查找social link字段 腾讯公益404 新建&lt;hexo-site&gt;/source/404.html 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 站点生成时间 编辑themes/next/_config.yml 1since: 2018 添加sitemap插件 安装 hexo-generator-sitemap 插件 1$ npm install hexo-generator-sitemap --save 编辑 _config.yml 12sitemap: path: sitemap.xml 添加蜘蛛协议 创建&lt;hexo-site&gt;/source/robots.txt 12345678910111213141516User-agent: *Disallow: /CNAMEDisallow: /READMEAllow: /Allow: /about/Allow: /archives/Allow: /categories/Allow: /tags/Allow: /css/Allow: /images/Allow: /js/Allow: /lib/Sitemap: &lt;your-domain-name&gt;/sitemap.xml 设置RSS 安装hexo-generator-feed 插件 1$ npm install hexo-generator-feed --save 编辑 _config.yml 123456feed: type: atom path: atom.xml limit: 20 # Maximum number of posts in the feed (Use 0 or false to show all posts) hub: content: Beautification Hexo+Next主题优化hexo + next主题高级配置 References Hexo - 修改永久链接的默认格式（重要）如何在一天之内搭建以你自己名字为域名又具备 cool 属性的个人博客hexo博客优化之实现来必力评论功能如何使用 Hexo 和 GitHub Pages 搭建这个博客使用 Travis 自动部署博客到 Github Pageshexo next主题 解决首页文章间距过宽的问题使用LaTex添加公式到Hexo博客里]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cheating Sheet]]></title>
    <url>%2Fpost%2Fd41a18cb.html</url>
    <content type="text"><![CDATA[Markdown 1个空格：&amp;nbsp; 字体、字号、颜色：&lt;font face=&quot;Charmonman&quot; size= 2 color=blue&gt;something&lt;/font&gt;test 段内换行：&lt;br\&gt; 显示摘要：&lt;!--more--&gt; Hexo 初始化目录：hexo init [folder] 新建文章：hexo new [layout] &lt;title&gt;或hexo n [layout] &lt;title&gt; 新建草稿：hexo new draft &lt;title&gt; 将草稿发布为正式文章：hexo publish &lt;title&gt; 生成静态文件：hexo generate或hexo g 监听文件变化：hexo g --watch 或 hexo g -w 部署：hexo deploy或hexo d 先生成后部署：hexo d -g 启动本地服务器（服务器会监听文件变化并自动更新）：hexo server或hexo s 启动调试：hexo s --debug 预览草稿：hexo s --draft 清除缓存：hexo clean LaTeX 常用数学符号的 LaTeX 表示方法]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
